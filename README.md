# clone-undertale

## Опис рішення

Ми створили клас `TextPrinter`, щоб реалізувати функціональність поступового виведення тексту на екран за допомогою бібліотеки Pygame. Цей клас дозволяє зручно й ефективно керувати процесом друку тексту на екрані, зберігаючи стан тексту та значення, необхідні для його виведення. Нижче наведено пояснення ключових компонентів цього коду.

### Ініціалізація Pygame
```python
from pygame import *
import time as t

init()

WIDTH = 500
HEIGHT = 500
window = display.set_mode((WIDTH, HEIGHT))
clock = time.Clock()
font1 = font.Font(None, 40)
```
На початку коду ми імпортуємо Pygame та модуль `time` для роботи з часом. Після цього ініціалізуємо Pygame та створюємо вікно розмірами 500x500 пікселів. Також створюємо об'єкт шрифту `font1`, який використовуватиметься для відображення тексту.

### Створення класу `TextPrinter`
```python
class TextPrinter:
    def __init__(self, text, font, speed=0.1, start_x=0, start_y=200):
        self.text = text  # Текст, який потрібно вивести на екран
        self.font = font  # Об'єкт шрифту для відображення тексту
        self.speed = speed  # Швидкість виведення символів
        self.x = start_x  # Початкова координата X для виведення тексту
        self.y = start_y  # Початкова координата Y для виведення тексту
        self.index = 0  # Індекс поточного символу, який буде виводитися
        self.start_time = t.time()  # Час початку для обчислення інтервалів між символами
```
Клас `TextPrinter` відповідає за друк тексту. Він має такі параметри:
- `text`: рядок тексту, який потрібно вивести на екран.
- `font`: об'єкт шрифту, що використовується для виведення тексту.
- `speed`: швидкість виведення символів (за замовчуванням 0.1 секунди).
- `start_x`, `start_y`: координати початку виведення тексту.
- `index`: індекс символу, який виводиться в даний момент.
- `start_time`: час початку для обчислення інтервалів між символами.

### Метод `print_text`
```python
    def print_text(self, surface):
        new_time = t.time()  # Отримуємо поточний час
        if new_time - self.start_time > self.speed:  # Перевіряємо, чи пройшов необхідний інтервал часу
            if self.index < len(self.text):  # Якщо ще є символи для виведення
                letter = self.font.render(f'{self.text[self.index]}', True, (255, 255, 255))  # Створюємо зображення символу
                letter_rect = letter.get_rect()  # Отримуємо розміри символу
                surface.blit(letter, (self.x, self.y))  # Відображаємо символ на екрані
                self.x += letter_rect.width  # Зміщуємо координату X для наступного символу
                self.index += 1  # Переходимо до наступного символу
                self.start_time = t.time()  # Оновлюємо час початку для наступного інтервалу
```
Метод `print_text` відповідає за поступове виведення символів. Кожного разу, коли пройшов інтервал `speed`, він малює наступний символ:
- Використовується `t.time()`, щоб визначити, чи пройшов час для виведення нового символу.
- Якщо індекс символу (`index`) менший за довжину тексту, малюємо поточний символ на екрані та збільшуємо значення `x` для наступного символу.
- Оновлюємо `start_time`, щоб почати відлік для наступного символу.

### Основний ігровий цикл
```python
printer = TextPrinter(text_list, font1)

while True:
    for e in event.get():
        if e.type == QUIT:  # Якщо користувач закриває вікно
            quit()

    window.fill((0, 0, 0))  # Очищаємо вікно перед малюванням нового кадру
    printer.print_text(window)  # Викликаємо метод для виведення тексту

    display.update()  # Оновлюємо екран
    clock.tick(60)  # Обмежуємо кількість кадрів до 60 на секунду
```
В основному ігровому циклі:
1. Очищаємо вікно кожного кадру (`window.fill((0, 0, 0))`).
2. Викликаємо метод `print_text` для об'єкта `printer`, щоб вивести текст на екран.
3. Оновлюємо екран (`display.update()`) та обмежуємо кількість кадрів до 60 на секунду (`clock.tick(60)`).

### Переваги використання класу `TextPrinter`
- **Інкапсуляція логіки виведення тексту**: Уся логіка виведення тексту зберігається в одному класі, що робить її легкою для розширення і використання в інших проєктах.
- **Гнучкість**: Клас можна використовувати для виведення різного тексту або змінювати швидкість виведення символів.
- **Чистий екран**: Завдяки очищенню екрана щоразу перед виведенням тексту, уникаємо накладання символів один на одного.

Цей підхід дозволяє зручно використовувати клас `TextPrinter` для виведення тексту в іграх або додатках, розроблених на Pygame.